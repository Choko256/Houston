/*
 * Copyright (c) 2020 Â· Marton Lederer
 * This file was created / generated by Marton Lederer
 * See the LICENSE on the github repo
 * https://github.com/MartonDev
 * https://marton.lederer.hu
 */

/*
*
* Time transport
*
* This will save your logs in a file
*
* */
import { Config, Format, ITransport, LogLevel, LogLevelDisplay, LogLevelIcon } from '../../../types.ts'
import { Transport } from '../Transport.ts'

export class FileTransport extends Transport implements ITransport {

  private readonly logFolder: string

  /*
  *
  * FileTransport
  *
  * @param logFolder  The folder where we generate the log files
  * @param level  Only log levels that are included here, logs all by default
  * @param config  Custom options, not required
  *
  * */
  constructor (logFolder: string, level: Array<LogLevel> = [LogLevel.Info, LogLevel.Success, LogLevel.Warning, LogLevel.Error], config?: Config | undefined) {

    super(level, config)
    this.logFolder = logFolder

  }

  async log (level: LogLevel, message: string) {

    for(const lvl in this.level)
      if(this.level.hasOwnProperty(lvl) && this.level[lvl] === level && typeof this.options !== 'undefined') {

        const
          logFileName = `${ this.logFolder }/${ this.level[lvl].toString() }.${ this.options.format === Format.json ? 'json' : 'log' }`,
          logFile = await Deno.open(logFileName, { write: true, create: true, read: true }),
          logContentEncoder = new TextEncoder(),
          logContentDecoder = new TextDecoder('utf-8'),
          currLogFileContent = logContentDecoder.decode(await Deno.readAll(logFile))

        switch (this.options.format) {

          case Format.json:

            let writeJSON = {}

            if(currLogFileContent === '') {

              writeJSON = {

                logs: [

                  {

                    prefix: (this.options.prefix.getPrefix() === '' ?

                        '' :
                        ('[' + this.options.prefix.getPrefix() + ']')

                    ),

                    logLevelDisplay: (this.options.logLevelDisplay === LogLevelDisplay.Text ?

                        (level.toString() + ':') :

                        (this.options.logLevelDisplay === LogLevelDisplay.Icon ?

                            LogLevelIcon[level] :
                            ''

                        )

                    ),
                    logLevel: level.toString(),
                    message: message

                  }

                ]

              }

            }else {

              const baseJSON = JSON.parse(currLogFileContent)

              baseJSON['logs'].push({

                prefix: (this.options.prefix.getPrefix() === '' ?

                    '' :
                    ('[' + this.options.prefix.getPrefix() + ']')

                ),

                logLevelDisplay: (this.options.logLevelDisplay === LogLevelDisplay.Text ?

                    (level.toString() + ':') :

                    (this.options.logLevelDisplay === LogLevelDisplay.Icon ?

                        LogLevelIcon[level] :
                        ''

                    )

                ),
                logLevel: level.toString(),
                message: message

              })
              writeJSON = baseJSON

            }

            await Deno.writeFile(logFileName, logContentEncoder.encode(JSON.stringify(writeJSON)))

            break

          case Format.text:
          default:

            await Deno.write(logFile.rid, logContentEncoder.encode(message + '\n'))

            break

        }

      }

  }

}